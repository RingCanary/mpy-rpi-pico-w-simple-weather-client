#!/usr/bin/env python3
"""
Host-side flashing workflow for MicroPython devices.

Reads .env from repo root, renders secrets/config.py, uploads to board
along with firmware main.py. Supports mpremote (default) or rshell backends.

Usage:
    python scripts/flash.py --target pico_w --backend mpremote
    python scripts/flash.py --target esp32_c6 --dry-run
    python scripts/flash.py --target pico_w --verify
"""

import argparse
import re
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import Optional

# Board target configurations
TARGETS = {
    "pico_w": {
        "device_pattern": "pico",
        "port_hint": "/dev/ttyACM",
    },
    "esp32_c6": {
        "device_pattern": "esp32",
        "port_hint": "/dev/ttyUSB",
    },
}

# Secrets template for config.py rendered on device
CONFIG_TEMPLATE = """# Auto-generated device config - DO NOT EDIT
# Generated by scripts/flash.py from .env

# Wi-Fi credentials
WIFI_SSID = "{wifi_ssid}"
WIFI_PASSWORD = "{wifi_password}"

# Pi5 API endpoint (device reports here)
PI5_HOST = "{pi5_host}"
PI5_PORT = {pi5_port}
INGEST_ENDPOINT = "{ingest_endpoint}"

# API key for authentication (optional)
API_KEY = "{api_key}"

# Device identity
DEVICE_ID = "{device_id}"
BOARD_TYPE = "{board_type}"

# Sampling interval (seconds)
SAMPLE_INTERVAL = {sample_interval}
"""


def parse_env(env_path: Path) -> dict:
    """Parse .env file manually without external dependencies."""
    env = {}
    if not env_path.exists():
        return env

    with open(env_path, "r") as f:
        for line in f:
            line = line.strip()
            # Skip empty lines and comments
            if not line or line.startswith("#"):
                continue
            # Parse KEY=value or KEY="value" or KEY='value'
            if "=" not in line:
                continue
            key, _, value = line.partition("=")
            key = key.strip()
            value = value.strip()
            # Remove quotes if present
            if (value.startswith('"') and value.endswith('"')) or (
                value.startswith("'") and value.endswith("'")
            ):
                value = value[1:-1]
            env[key] = value
    return env


def get_device_port(target: str) -> Optional[str]:
    """Auto-detect device port for given target."""
    config = TARGETS.get(target)
    if not config:
        return None

    # Try target-specific hint first, then common fallback
    port_patterns = [config["port_hint"], "/dev/ttyACM", "/dev/ttyUSB"]

    for pattern in port_patterns:
        for i in range(5):
            port = f"{pattern}{i}"
            if Path(port).exists():
                return port
    return None


def run_command(cmd: list, dry_run: bool = False) -> tuple:
    """Run a shell command, returning (success, output)."""
    if dry_run:
        print(f"[DRY-RUN] Would run: {' '.join(cmd)}")
        return True, ""

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
        return result.returncode == 0, result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return False, "Command timed out"
    except FileNotFoundError:
        return False, f"Command not found: {cmd[0]}"


def parse_api_url(api_url: str) -> tuple[str, str, str]:
    """Parse API URL into host, port, path with safe defaults."""
    match = re.match(r"https?://([^/:]+)(?::(\d+))?(/.*)?$", api_url)
    if not match:
        return "pi5.local", "8000", "/ingest"

    host = match.group(1)
    port = match.group(2) or ("443" if api_url.startswith("https") else "8000")
    path = match.group(3) or "/ingest"
    return host, port, path


def _target_env(env: dict, target: str, key: str, default: str) -> str:
    """Read target-specific env override, then generic key, then default."""
    target_key = f"{target.upper()}_{key}"
    return env.get(target_key, env.get(key, default))


def _py_escape(value: str) -> str:
    """Escape a Python string literal value for generated config.py."""
    return value.replace("\\", "\\\\").replace('"', '\\"')


def render_config(env: dict, target: str) -> str:
    """Render config.py content from env vars."""
    api_url = env.get("API_URL", "http://pi5.local:8000/ingest")
    pi5_host, pi5_port, ingest_endpoint = parse_api_url(api_url)
    raw_interval = _target_env(env, target, "SAMPLE_INTERVAL", "60")
    try:
        sample_interval = int(raw_interval)
    except ValueError:
        sample_interval = 60

    return CONFIG_TEMPLATE.format(
        wifi_ssid=_py_escape(_target_env(env, target, "WIFI_SSID", "YOUR_WIFI_SSID")),
        wifi_password=_py_escape(_target_env(env, target, "WIFI_PASSWORD", "YOUR_WIFI_PASSWORD")),
        pi5_host=pi5_host,
        pi5_port=pi5_port,
        ingest_endpoint=_py_escape(ingest_endpoint),
        api_key=_py_escape(env.get("API_KEY", "")),
        device_id=_py_escape(_target_env(env, target, "DEVICE_ID", target)),
        board_type=target,
        sample_interval=sample_interval,
    )


def find_firmware_main(target: str) -> Optional[Path]:
    """Find the target-specific firmware main.py file."""
    repo_root = Path(__file__).parent.parent

    # Check target-specific location first
    candidates = [
        repo_root / "firmware" / target / "main.py",
        repo_root / "firmware" / "main.py",  # fallback
    ]

    for candidate in candidates:
        if candidate.exists():
            return candidate
    return None


def flash_mpremote(
    port: str,
    config_content: str,
    main_path: Optional[Path],
    dry_run: bool = False,
    verify: bool = False,
) -> bool:
    """Flash using mpremote backend."""

    # Write config to temp file
    config_tmp = Path(tempfile.gettempdir()) / "pi5_hub_config.py"
    if not dry_run:
        config_tmp.write_text(config_content, encoding="utf-8")
    else:
        print(f"[DRY-RUN] Would write config to {config_tmp}")

    # Build base command
    base_cmd = ["mpremote", "connect", port]

    # Upload config.py
    success, output = run_command(base_cmd + ["cp", str(config_tmp), ":config.py"], dry_run)
    if not success and not dry_run:
        print(f"Failed to upload config.py: {output}")
        return False
    print(f"Uploaded config.py to {port}")

    # Upload main.py if exists
    if main_path and main_path.exists():
        success, output = run_command(base_cmd + ["cp", str(main_path), ":main.py"], dry_run)
        if not success and not dry_run:
            print(f"Failed to upload main.py: {output}")
            return False
        print(f"Uploaded main.py to {port}")
    else:
        print("No firmware main.py found, skipping")

    # Verify by listing files
    if verify and not dry_run:
        print("\nVerifying uploaded files:")
        success, output = run_command(base_cmd + ["ls", ":"], False)
        if success:
            print(output)
        else:
            print(f"Failed to list files: {output}")
    elif verify and dry_run:
        print("[DRY-RUN] Would verify by listing device files")

    # Cleanup temp file
    if not dry_run and config_tmp.exists():
        config_tmp.unlink()

    return True


def flash_rshell(
    port: str,
    config_content: str,
    main_path: Optional[Path],
    dry_run: bool = False,
    verify: bool = False,
) -> bool:
    """Flash using rshell backend."""

    # Write config to temp file
    config_tmp = Path(tempfile.gettempdir()) / "pi5_hub_config.py"
    if not dry_run:
        config_tmp.write_text(config_content, encoding="utf-8")
    else:
        print(f"[DRY-RUN] Would write config to {config_tmp}")

    # Upload config.py using rshell
    success, output = run_command(
        ["rshell", "-p", port, "cp", str(config_tmp), "/pyboard/config.py"], dry_run
    )
    if not success and not dry_run:
        print(f"Failed to upload config.py: {output}")
        return False
    print(f"Uploaded config.py to {port}")

    # Upload main.py if exists
    if main_path and main_path.exists():
        success, output = run_command(
            ["rshell", "-p", port, "cp", str(main_path), "/pyboard/main.py"], dry_run
        )
        if not success and not dry_run:
            print(f"Failed to upload main.py: {output}")
            return False
        print(f"Uploaded main.py to {port}")
    else:
        print("No firmware main.py found, skipping")

    # Verify by listing files
    if verify and not dry_run:
        print("\nVerifying uploaded files:")
        success, output = run_command(["rshell", "-p", port, "ls", "/pyboard/"], False)
        if success:
            print(output)
        else:
            print(f"Failed to list files: {output}")
    elif verify and dry_run:
        print("[DRY-RUN] Would verify by listing device files")

    # Cleanup temp file
    if not dry_run and config_tmp.exists():
        config_tmp.unlink()

    return True


def main():
    parser = argparse.ArgumentParser(
        description="Flash MicroPython devices with config and firmware"
    )
    parser.add_argument(
        "--target",
        "-t",
        choices=list(TARGETS.keys()),
        required=True,
        help="Board target (pico_w, esp32_c6)",
    )
    parser.add_argument(
        "--backend",
        "-b",
        choices=["mpremote", "rshell"],
        default="mpremote",
        help="Flash backend (default: mpremote)",
    )
    parser.add_argument("--port", "-p", help="Serial port (auto-detected if not specified)")
    parser.add_argument(
        "--dry-run", "-n", action="store_true", help="Show commands without executing"
    )
    parser.add_argument(
        "--verify", "-v", action="store_true", help="List files after upload to verify"
    )
    parser.add_argument(
        "--env-file", default=".env", help="Path to .env file (default: .env in repo root)"
    )

    args = parser.parse_args()

    repo_root = Path(__file__).parent.parent
    env_path = repo_root / args.env_file

    # Parse .env
    print(f"Reading environment from: {env_path}")
    env = parse_env(env_path)

    if not env:
        print(f"Warning: No variables loaded from {env_path}")
        print("Will use placeholder values in config")
    else:
        print(f"Loaded {len(env)} variables from .env")

    # Determine port
    port = args.port
    if not port:
        port = get_device_port(args.target)
        if not port:
            print(f"Error: Could not auto-detect port for {args.target}")
            print("Please specify --port manually")
            sys.exit(1)
        print(f"Auto-detected port: {port}")

    # Render config
    config_content = render_config(env, args.target)
    print(f"\nRendered config.py for target: {args.target}")

    # Find firmware main.py for target
    main_path = find_firmware_main(args.target)
    if main_path:
        print(f"Found firmware: {main_path}")
    else:
        print(f"No firmware main.py found for target {args.target} (will only upload config)")

    # Flash using selected backend
    print(f"\nFlashing using {args.backend}...")

    if args.backend == "mpremote":
        success = flash_mpremote(port, config_content, main_path, args.dry_run, args.verify)
    else:
        success = flash_rshell(port, config_content, main_path, args.dry_run, args.verify)

    if success:
        print("\nFlash complete!")
        if args.dry_run:
            print("(Dry run - no changes made)")
    else:
        print("\nFlash failed!")
        sys.exit(1)


if __name__ == "__main__":
    main()
